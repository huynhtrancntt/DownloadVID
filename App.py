import sys
import os
import subprocess
import glob
import logging
import requests
import json
import webbrowser
from datetime import datetime
from PySide6.QtWidgets import (
    QApplication, QWidget, QLabel, QVBoxLayout, QPushButton,
    QTextEdit, QCheckBox, QComboBox, QRadioButton,
    QHBoxLayout, QButtonGroup, QMessageBox, QProgressBar, QListWidget, QListWidgetItem,
    QFileDialog, QMenuBar, QMenu, QDialog
)
from PySide6.QtCore import Qt, QThread, Signal, QSettings, QTimer
from PySide6.QtGui import QScreen, QAction, QIcon
import shutil
import zipfile

# Thi·∫øt l·∫≠p logging


def setup_logging():
    """Thi·∫øt l·∫≠p h·ªá th·ªëng logging"""
    log_file = os.path.join(os.getcwd(), "DownloadVID.log")

    # T·∫°o logger
    logger = logging.getLogger('DownloadVID')
    logger.setLevel(logging.DEBUG)

    # X√≥a c√°c handler c≈© n·∫øu c√≥
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    # File handler
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)

    # Console handler (ch·ªâ khi c√≥ console)
    if hasattr(sys, '_MEIPASS'):
        # ƒêang ch·∫°y t·ª´ exe, kh√¥ng c√≥ console
        console_handler = None
    else:
        # ƒêang ch·∫°y t·ª´ Python, c√≥ console
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)

    # Formatter
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    if console_handler:
        console_handler.setFormatter(formatter)

    # Th√™m handlers
    logger.addHandler(file_handler)
    if console_handler:
        logger.addHandler(console_handler)

    return logger


# Kh·ªüi t·∫°o logger
logger = setup_logging()

# Phi√™n b·∫£n ·ª©ng d·ª•ng
APP_VERSION = "1.0.0"
# URL ƒë·ªÉ ki·ªÉm tra phi√™n b·∫£n m·ªõi
UPDATE_CHECK_URL = "https://raw.githubusercontent.com/huynhtrancntt/auto_update/main/update.json"


class DownloadUpdateWorker(QThread):
    """Worker thread ƒë·ªÉ t·∫£i ·ªÅ v√† gi·∫£i n√©n update"""
    progress_signal = Signal(int)
    message_signal = Signal(str)
    finished_signal = Signal(bool, str)  # success, message

    def __init__(self, download_url, version):
        super().__init__()
        self.download_url = download_url
        self.version = version
        self.stop_flag = False

    def run(self):
        """Th·ª±c hi·ªán download v√† extract"""
        try:
            # T·∫°o t√™n file
            output_file = f"update_v{self.version}.zip"
            extract_to = "temp_update"

            # B∆∞·ªõc 1: Download file
            self.message_signal.emit("‚¨áÔ∏è ƒêang t·∫£i file c·∫≠p nh·∫≠t...")
            if not self._download_with_progress(self.download_url, output_file):
                return

            if self.stop_flag:
                self._cleanup(output_file, extract_to)
                return

            # B∆∞·ªõc 2: Gi·∫£i n√©n
            self.message_signal.emit("üì¶ ƒêang gi·∫£i n√©n file...")
            self.progress_signal.emit(0)

            if not self._extract_and_install(output_file, extract_to):
                return

            # B∆∞·ªõc 3: Ho√†n th√†nh
            self.message_signal.emit("‚úÖ C·∫≠p nh·∫≠t ho√†n t·∫•t!")
            self.progress_signal.emit(100)
            self.finished_signal.emit(
                True, f"C·∫≠p nh·∫≠t th√†nh c√¥ng l√™n phi√™n b·∫£n {self.version}!")

        except Exception as e:
            self.finished_signal.emit(False, f"L·ªói c·∫≠p nh·∫≠t: {str(e)}")

    def _download_with_progress(self, url, output_file):
        """T·∫£i file v·ªõi thanh ti·∫øn tr√¨nh"""
        try:
            response = requests.get(url, stream=True, timeout=30)
            response.raise_for_status()

            total_size = int(response.headers.get('content-length', 0))
            total_mb = total_size / (1024 * 1024)

            downloaded = 0
            chunk_size = 1024 * 1024  # 1MB

            with open(output_file, 'wb') as f:
                for chunk in response.iter_content(chunk_size=chunk_size):
                    if self.stop_flag:
                        f.close()
                        if os.path.exists(output_file):
                            os.remove(output_file)
                        self.message_signal.emit("‚èπ ƒê√£ d·ª´ng t·∫£i")
                        return False

                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        downloaded_mb = downloaded / (1024 * 1024)

                        if total_mb > 0:
                            percent = int((downloaded_mb / total_mb) * 100)
                            self.progress_signal.emit(percent)
                            self.message_signal.emit(
                                f"‚¨áÔ∏è ƒêang t·∫£i: {downloaded_mb:.1f}/{total_mb:.1f} MB ({percent}%)")
                        else:
                            self.message_signal.emit(
                                f"‚¨áÔ∏è ƒê√£ t·∫£i: {downloaded_mb:.1f} MB")

            self.message_signal.emit("‚úÖ T·∫£i xu·ªëng ho√†n t·∫•t!")
            return True

        except Exception as e:
            self.message_signal.emit(f"‚ùå L·ªói t·∫£i xu·ªëng: {str(e)}")
            if os.path.exists(output_file):
                os.remove(output_file)
            return False

    def _extract_and_install(self, zip_file, extract_to):
        """Gi·∫£i n√©n v√† c√†i ƒë·∫∑t c·∫≠p nh·∫≠t"""
        try:
            # X√≥a th∆∞ m·ª•c t·∫°m c≈© n·∫øu c√≥
            if os.path.exists(extract_to):
                shutil.rmtree(extract_to)
            os.makedirs(extract_to)

            # Gi·∫£i n√©n
            with zipfile.ZipFile(zip_file, 'r') as zip_ref:
                file_list = zip_ref.namelist()
                total_files = len(file_list)

                for i, file_name in enumerate(file_list):
                    if self.stop_flag:
                        self._cleanup(zip_file, extract_to)
                        return False

                    zip_ref.extract(file_name, extract_to)
                    # 50% cho extract
                    percent = int((i + 1) / total_files * 50)
                    self.progress_signal.emit(percent)
                    self.message_signal.emit(f"üì¶ Gi·∫£i n√©n: {file_name}")

            # Copy files
            self.message_signal.emit("üìã ƒêang c·∫≠p nh·∫≠t files...")
            current_dir = os.getcwd()

            copied_files = []
            for root, dirs, files in os.walk(extract_to):
                for file in files:
                    if self.stop_flag:
                        self._cleanup(zip_file, extract_to)
                        return False

                    src_file = os.path.join(root, file)
                    rel_path = os.path.relpath(src_file, extract_to)
                    dst_file = os.path.join(current_dir, rel_path)

                    # T·∫°o th∆∞ m·ª•c ƒë√≠ch n·∫øu ch∆∞a c√≥
                    dst_dir = os.path.dirname(dst_file)
                    if dst_dir and not os.path.exists(dst_dir):
                        os.makedirs(dst_dir)

                    # Copy file
                    shutil.copy2(src_file, dst_file)
                    copied_files.append(rel_path)
                    self.message_signal.emit(f"üìã C·∫≠p nh·∫≠t: {rel_path}")

            # L∆∞u phi√™n b·∫£n m·ªõi v√†o file
            try:
                version_file = os.path.join(current_dir, "version.txt")
                with open(version_file, 'w', encoding='utf-8') as f:
                    f.write(self.version)
                self.message_signal.emit(
                    f"üíæ ƒê√£ l∆∞u phi√™n b·∫£n m·ªõi: {self.version}")
            except Exception as e:
                self.message_signal.emit(f"‚ö†Ô∏è Kh√¥ng th·ªÉ l∆∞u phi√™n b·∫£n: {e}")

            # D·ªçn d·∫πp
            self.message_signal.emit("üßπ ƒêang d·ªçn d·∫πp...")
            self._cleanup(zip_file, extract_to)

            self.progress_signal.emit(100)
            self.message_signal.emit(
                f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t {len(copied_files)} files")
            return True

        except Exception as e:
            self.message_signal.emit(f"‚ùå L·ªói gi·∫£i n√©n: {str(e)}")
            self._cleanup(zip_file, extract_to)
            return False

    def _cleanup(self, zip_file, extract_to):
        """D·ªçn d·∫πp files t·∫°m"""
        try:
            if os.path.exists(zip_file):
                os.remove(zip_file)
            if os.path.exists(extract_to):
                shutil.rmtree(extract_to)
        except:
            pass

    def stop(self):
        """D·ª´ng qu√° tr√¨nh download"""
        self.stop_flag = True


class UpdateChecker(QThread):
    """Worker thread ƒë·ªÉ ki·ªÉm tra update"""
    update_available = Signal(dict)
    no_update = Signal()
    error_occurred = Signal(str)

    def __init__(self):
        super().__init__()

    def run(self):
        """Ki·ªÉm tra phi√™n b·∫£n m·ªõi"""
        try:
            debug_print("üîç ƒêang ki·ªÉm tra phi√™n b·∫£n m·ªõi...")

            # G·ª≠i request ƒë·ªÉ l·∫•y th√¥ng tin release m·ªõi nh·∫•t
            response = requests.get(UPDATE_CHECK_URL, timeout=10)

            if response.status_code == 200:
                release_data = response.json()
                latest_version = release_data.get(
                    'tag_name', '').replace('v', '')
                release_name = release_data.get('name', '')
                release_notes = release_data.get('body', '')
                # L·∫•y download URL t·ª´ JSON response
                download_url = release_data.get('download_url', '')
                if not download_url:
                    # Fallback n·∫øu kh√¥ng c√≥ download_url, c√≥ th·ªÉ th·ª≠ c√°c key kh√°c
                    download_url = release_data.get('html_url', '')
                    if not download_url:
                        download_url = release_data.get('zipball_url', '')
                
                # Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa download URL
                if not download_url or not download_url.startswith(('http://', 'https://')):
                    self.error_occurred.emit("Kh√¥ng t√¨m th·∫•y URL download h·ª£p l·ªá trong response")
                    return
                
                published_at = release_data.get('published_at', '')
                debug_print(f"üì• Download URL t·ª´ JSON: {download_url}")
                
                # So s√°nh phi√™n b·∫£n
                if self._is_newer_version(latest_version, APP_VERSION):
                    update_info = {
                        'version': latest_version,
                        'name': release_name,
                        'notes': release_notes,
                        'download_url': download_url,
                        'published_at': published_at
                    }
                    self.update_available.emit(update_info)
                else:
                    self.no_update.emit()
            else:
                self.error_occurred.emit(
                    f"HTTP {response.status_code}: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server")

        except requests.exceptions.Timeout:
            self.error_occurred.emit(
                "Timeout: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server trong th·ªùi gian quy ƒë·ªãnh")
        except requests.exceptions.ConnectionError:
            self.error_occurred.emit("L·ªói k·∫øt n·ªëi: Ki·ªÉm tra k·∫øt n·ªëi internet")
        except Exception as e:
            self.error_occurred.emit(f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}")

    def _is_newer_version(self, latest, current):
        """So s√°nh 2 phi√™n b·∫£n"""
        try:
            # Chuy·ªÉn ƒë·ªïi version string th√†nh list s·ªë
            latest_parts = [int(x) for x in latest.split('.')]
            current_parts = [int(x) for x in current.split('.')]

            # ƒê·∫£m b·∫£o c·∫£ 2 list c√≥ c√πng ƒë·ªô d√†i
            max_len = max(len(latest_parts), len(current_parts))
            latest_parts.extend([0] * (max_len - len(latest_parts)))
            current_parts.extend([0] * (max_len - len(current_parts)))

            # So s√°nh t·ª´ng ph·∫ßn
            for i in range(max_len):
                if latest_parts[i] > current_parts[i]:
                    return True
                elif latest_parts[i] < current_parts[i]:
                    return False

            return False  # B·∫±ng nhau
        except:
            return False


class UpdateDialog(QDialog):
    """Dialog hi·ªÉn th·ªã th√¥ng tin update"""

    def __init__(self, update_info, parent=None):
        super().__init__(parent)
        self.update_info = update_info
        self.download_worker = None
        self.init_ui()

    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán dialog"""
        self.setWindowTitle("üîÑ C·∫≠p nh·∫≠t c√≥ s·∫µn")
        self.setMinimumWidth(600)
        self.setMinimumHeight(500)

        layout = QVBoxLayout()
        self.setLayout(layout)

        # Ti√™u ƒë·ªÅ
        title_label = QLabel(
            f"üéâ Phi√™n b·∫£n m·ªõi c√≥ s·∫µn: v{self.update_info['version']}")
        title_label.setStyleSheet(
            "font-size: 16px; font-weight: bold; color: #28a745; margin: 10px;")
        layout.addWidget(title_label)

        # Th√¥ng tin phi√™n b·∫£n hi·ªán t·∫°i
        current_label = QLabel(f"üì± Phi√™n b·∫£n hi·ªán t·∫°i: v{APP_VERSION}")
        current_label.setStyleSheet(
            "font-size: 13px; color: #6c757d; margin: 5px;")
        layout.addWidget(current_label)

        # T√™n release
        if self.update_info.get('name'):
            name_label = QLabel(f"üìã T√™n phi√™n b·∫£n: {self.update_info['name']}")
            name_label.setStyleSheet("font-size: 13px; margin: 5px;")
            layout.addWidget(name_label)

        # Ng√†y ph√°t h√†nh
        if self.update_info.get('published_at'):
            try:
                from datetime import datetime
                pub_date = datetime.fromisoformat(
                    self.update_info['published_at'].replace('Z', '+00:00'))
                date_str = pub_date.strftime("%d/%m/%Y %H:%M")
                date_label = QLabel(f"üìÖ Ng√†y ph√°t h√†nh: {date_str}")
                date_label.setStyleSheet("font-size: 13px; margin: 5px;")
                layout.addWidget(date_label)
            except:
                pass

        # Release notes
        if self.update_info.get('notes'):
            notes_label = QLabel("üìù Ghi ch√∫ phi√™n b·∫£n:")
            notes_label.setStyleSheet("font-weight: bold; margin-top: 15px;")
            layout.addWidget(notes_label)

            notes_text = QTextEdit()
            notes_text.setPlainText(self.update_info['notes'])
            notes_text.setReadOnly(True)
            notes_text.setMaximumHeight(120)
            layout.addWidget(notes_text)

        # Progress bar (·∫©n ban ƒë·∫ßu)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Log area (·∫©n ban ƒë·∫ßu)
        self.log_area = QTextEdit()
        self.log_area.setMaximumHeight(100)
        self.log_area.setReadOnly(True)
        self.log_area.setVisible(False)
        self.log_area.setStyleSheet("""
            QTextEdit {
                background-color: #2d3748;
                color: #e2e8f0;
                border: 1px solid #4a5568;
                border-radius: 4px;
                font-family: 'Consolas', monospace;
                font-size: 11px;
                padding: 5px;
            }
        """)
        layout.addWidget(self.log_area)

        # Buttons
        button_layout = QHBoxLayout()

        # N√∫t t·∫£i v·ªÅ t·ª± ƒë·ªông
        self.auto_download_button = QPushButton("üöÄ T·∫£i v·ªÅ & C√†i ƒë·∫∑t t·ª± ƒë·ªông")
        self.auto_download_button.clicked.connect(self.start_auto_download)
        self.auto_download_button.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #218838;
            }
            QPushButton:disabled {
                background-color: #6c757d;
            }
        """)

        # N√∫t t·∫£i v·ªÅ th·ªß c√¥ng
        download_button = QPushButton("üîó T·∫£i v·ªÅ th·ªß c√¥ng")
        download_button.clicked.connect(self.download_update)
        download_button.setStyleSheet("""
            QPushButton {
                background-color: #007bff;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #0056b3;
            }
        """)

        # N√∫t d·ª´ng (·∫©n ban ƒë·∫ßu)
        self.stop_button = QPushButton("‚èπ D·ª´ng")
        self.stop_button.clicked.connect(self.stop_download)
        self.stop_button.setVisible(False)
        self.stop_button.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
        """)

        later_button = QPushButton("‚è∞ ƒê·ªÉ sau")
        later_button.clicked.connect(self.reject)
        later_button.setStyleSheet("""
            QPushButton {
                background-color: #6c757d;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #545b62;
            }
        """)

        button_layout.addWidget(self.auto_download_button)
        button_layout.addWidget(download_button)
        button_layout.addWidget(self.stop_button)
        button_layout.addWidget(later_button)
        layout.addLayout(button_layout)

    def start_auto_download(self):
        """B·∫Øt ƒë·∫ßu t·∫£i v·ªÅ t·ª± ƒë·ªông"""
        # Ki·ªÉm tra xem c√≥ URL download kh√¥ng
        if not self.update_info.get('download_url'):
            self.add_log("‚ùå Kh√¥ng c√≥ URL download h·ª£p l·ªá")
            QMessageBox.warning(self, "L·ªói", "‚ùå Kh√¥ng c√≥ URL download h·ª£p l·ªá.\nVui l√≤ng th·ª≠ t·∫£i v·ªÅ th·ªß c√¥ng.")
            return
        
        # Hi·ªÉn th·ªã progress bar v√† log area
        self.progress_bar.setVisible(True)
        self.log_area.setVisible(True)
        self.progress_bar.setValue(0)

        # ·∫®n n√∫t t·∫£i v·ªÅ, hi·ªán n√∫t d·ª´ng
        self.auto_download_button.setVisible(False)
        self.stop_button.setVisible(True)

        # Resize dialog ƒë·ªÉ ch·ª©a c√°c th√†nh ph·∫ßn m·ªõi
        self.resize(600, 650)

        # T·∫°o v√† ch·∫°y worker
        self.download_worker = DownloadUpdateWorker(
            self.update_info['download_url'], self.update_info['version'])
        self.download_worker.progress_signal.connect(self.update_progress)
        self.download_worker.message_signal.connect(self.add_log)
        self.download_worker.finished_signal.connect(self.on_download_finished)
        self.download_worker.start()

    def stop_download(self):
        """D·ª´ng qu√° tr√¨nh t·∫£i v·ªÅ"""
        if self.download_worker and self.download_worker.isRunning():
            self.download_worker.stop()
            self.add_log("‚èπ ƒêang d·ª´ng...")

    def update_progress(self, value):
        """C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh"""
        self.progress_bar.setValue(value)

    def add_log(self, message):
        """Th√™m message v√†o log"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        self.log_area.append(f"[{timestamp}] {message}")
        # Cu·ªôn xu·ªëng cu·ªëi
        cursor = self.log_area.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        self.log_area.setTextCursor(cursor)

    def on_download_finished(self, success, message):
        """X·ª≠ l√Ω khi t·∫£i v·ªÅ ho√†n th√†nh"""
        # Hi·ªán l·∫°i n√∫t t·∫£i v·ªÅ, ·∫©n n√∫t d·ª´ng
        self.auto_download_button.setVisible(True)
        self.stop_button.setVisible(False)

        if success:
            # T·∫°o custom dialog v·ªõi 3 l·ª±a ch·ªçn
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("C·∫≠p nh·∫≠t th√†nh c√¥ng")
            msg_box.setText(f"‚úÖ {message}\n\nCh·ªçn c√°ch √°p d·ª•ng c·∫≠p nh·∫≠t:")
            msg_box.setInformativeText(
                "üîÑ Kh·ªüi ƒë·ªông l·∫°i t·ª± ƒë·ªông: ·ª®ng d·ª•ng s·∫Ω t·ª± ƒë·ªông kh·ªüi ƒë·ªông l·∫°i\n"
                "üõë T·∫Øt v√† m·ªü l·∫°i th·ªß c√¥ng: T·∫Øt ·ª©ng d·ª•ng, b·∫°n t·ª± m·ªü l·∫°i\n"
                "‚è∞ ƒê·ªÉ sau: Ti·∫øp t·ª•c s·ª≠ d·ª•ng, kh·ªüi ƒë·ªông l·∫°i khi thu·∫≠n ti·ªán"
            )

            # T·∫°o c√°c n√∫t t√πy ch·ªçn
            auto_restart_btn = msg_box.addButton(
                "üîÑ Kh·ªüi ƒë·ªông l·∫°i t·ª± ƒë·ªông", QMessageBox.ButtonRole.AcceptRole)
            close_app_btn = msg_box.addButton(
                "üõë T·∫Øt app", QMessageBox.ButtonRole.DestructiveRole)
            later_btn = msg_box.addButton(
                "‚è∞ ƒê·ªÉ sau", QMessageBox.ButtonRole.RejectRole)

            # ƒê·∫∑t n√∫t m·∫∑c ƒë·ªãnh
            msg_box.setDefaultButton(auto_restart_btn)

            # Hi·ªÉn th·ªã dialog v√† x·ª≠ l√Ω k·∫øt qu·∫£
            msg_box.exec()
            clicked_button = msg_box.clickedButton()

            if clicked_button == auto_restart_btn:
                # Kh·ªüi ƒë·ªông l·∫°i t·ª± ƒë·ªông
                self.restart_application()
            elif clicked_button == close_app_btn:
                # T·∫Øt ·ª©ng d·ª•ng
                self.close_application()
            else:
                # ƒê·ªÉ sau
                QMessageBox.information(self, "Th√¥ng b√°o",
                                        "‚úÖ C·∫≠p nh·∫≠t ƒë√£ ho√†n t·∫•t!\n\n"
                                        "Vui l√≤ng kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng th·ªß c√¥ng ƒë·ªÉ √°p d·ª•ng thay ƒë·ªïi.")

            self.accept()
        else:
            QMessageBox.warning(self, "L·ªói", f"‚ùå {message}")
            # C√≥ th·ªÉ th·ª≠ l·∫°i
            self.auto_download_button.setEnabled(True)

    def close_application(self):
        """T·∫Øt ·ª©ng d·ª•ng ho√†n to√†n"""
        try:
            self.add_log("üõë ƒêang t·∫Øt ·ª©ng d·ª•ng...")

            # Hi·ªÉn th·ªã th√¥ng b√°o cu·ªëi c√πng
            final_msg = QMessageBox(self)
            final_msg.setWindowTitle("T·∫Øt ·ª©ng d·ª•ng")
            final_msg.setText("üõë ·ª®ng d·ª•ng s·∫Ω ƒë∆∞·ª£c t·∫Øt sau 3 gi√¢y")
            final_msg.setInformativeText(
                "‚úÖ C·∫≠p nh·∫≠t ƒë√£ ho√†n t·∫•t!\n\n"
                "Vui l√≤ng m·ªü l·∫°i ·ª©ng d·ª•ng ƒë·ªÉ s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi.\n"
                "C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng HT DownloadVID! üíñ"
            )
            final_msg.setStandardButtons(QMessageBox.StandardButton.Ok)

            # T·∫°o timer ƒë·ªÉ t·ª± ƒë·ªông ƒë√≥ng dialog v√† t·∫Øt app
            close_timer = QTimer()
            close_timer.setSingleShot(True)
            close_timer.timeout.connect(
                lambda: [final_msg.accept(), QApplication.instance().quit()])
            close_timer.start(3000)  # 3 gi√¢y

            # Hi·ªÉn th·ªã dialog
            final_msg.exec()

        except Exception as e:
            self.add_log(f"‚ùå L·ªói khi t·∫Øt ·ª©ng d·ª•ng: {str(e)}")
            # Fallback: t·∫Øt ngay l·∫≠p t·ª©c
            QApplication.instance().quit()

    def restart_application(self):
        """Kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng"""
        try:
            self.add_log("üîÑ ƒêang chu·∫©n b·ªã kh·ªüi ƒë·ªông l·∫°i...")

            # L·∫•y ƒë∆∞·ªùng d·∫´n executable hi·ªán t·∫°i
            if hasattr(sys, '_MEIPASS'):
                # ƒêang ch·∫°y t·ª´ exe ƒë∆∞·ª£c ƒë√≥ng g√≥i
                executable = sys.executable
                self.add_log(f"üìç Exe path: {executable}")
            else:
                # ƒêang ch·∫°y t·ª´ Python script
                executable = sys.executable
                script_path = os.path.abspath(__file__)
                self.add_log(f"üìç Python: {executable}")
                self.add_log(f"üìç Script: {script_path}")

            # T·∫°o m·ªôt timer ƒë·ªÉ delay tr∆∞·ªõc khi kh·ªüi ƒë·ªông l·∫°i
            self.add_log("‚è±Ô∏è S·∫Ω kh·ªüi ƒë·ªông l·∫°i sau 2 gi√¢y...")

            # S·ª≠ d·ª•ng QTimer ƒë·ªÉ delay
            restart_timer = QTimer()
            restart_timer.setSingleShot(True)
            restart_timer.timeout.connect(lambda: self._perform_restart(
                executable, script_path if not hasattr(sys, '_MEIPASS') else None))
            restart_timer.start(2000)  # 2 gi√¢y delay

        except Exception as e:
            self.add_log(f"‚ùå L·ªói chu·∫©n b·ªã kh·ªüi ƒë·ªông l·∫°i: {str(e)}")
            QMessageBox.warning(self, "L·ªói",
                                f"‚ùå Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông l·∫°i t·ª± ƒë·ªông: {str(e)}\n\n"
                                f"Vui l√≤ng kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng th·ªß c√¥ng.")

    def _perform_restart(self, executable, script_path=None):
        """Th·ª±c hi·ªán kh·ªüi ƒë·ªông l·∫°i"""
        try:
            self.add_log("üöÄ ƒêang kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng...")

            # Kh·ªüi ƒë·ªông process m·ªõi tr∆∞·ªõc khi ƒë√≥ng app hi·ªán t·∫°i
            if script_path:
                # Kh·ªüi ƒë·ªông Python script
                subprocess.Popen([executable, script_path],
                                 creationflags=subprocess.CREATE_NEW_CONSOLE if sys.platform == "win32" else 0)
                self.add_log("‚úÖ ƒê√£ kh·ªüi ƒë·ªông Python script m·ªõi")
            else:
                # Kh·ªüi ƒë·ªông exe
                subprocess.Popen([executable])
                self.add_log("‚úÖ ƒê√£ kh·ªüi ƒë·ªông exe m·ªõi")

            # ƒê√≥ng ·ª©ng d·ª•ng hi·ªán t·∫°i sau khi kh·ªüi ƒë·ªông th√†nh c√¥ng
            # 1 gi√¢y delay tr∆∞·ªõc khi quit
            QTimer.singleShot(1000, QApplication.instance().quit)

        except Exception as e:
            self.add_log(f"‚ùå L·ªói kh·ªüi ƒë·ªông l·∫°i: {str(e)}")
            QMessageBox.warning(self, "L·ªói",
                                f"‚ùå Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông l·∫°i t·ª± ƒë·ªông: {str(e)}\n\n"
                                f"Vui l√≤ng kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng th·ªß c√¥ng.")

    def download_update(self):
        """M·ªü trang download th·ªß c√¥ng"""
        try:
            webbrowser.open(self.update_info['download_url'])
            self.accept()
        except Exception as e:
            QMessageBox.warning(self, "L·ªói", f"Kh√¥ng th·ªÉ m·ªü tr√¨nh duy·ªát: {e}")


def debug_print(message):
    """In debug message - s·∫Ω ghi v√†o file log khi kh√¥ng c√≥ console"""
    logger.info(message)
    # V·∫´n gi·ªØ print cho compatibility
    try:
        print(message)
    except:
        pass  # B·ªè qua n·∫øu kh√¥ng c√≥ console


def resource_path(relative_path):
    """Tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi ƒë·∫øn file resource"""
    if hasattr(sys, '_MEIPASS'):
        return os.path.join(sys._MEIPASS, relative_path)
    return os.path.join(os.path.abspath("."), relative_path)


# Thi·∫øt l·∫≠p ƒë∆∞·ªùng d·∫´n ffmpeg v√† ki·ªÉm tra
ffmpeg_path = resource_path(os.path.join("ffmpeg", "ffmpeg.exe"))

# G·ªçi th·ª≠ ffmpeg
try:
    result = subprocess.run([ffmpeg_path, "-version"],
                            capture_output=True, text=True)
    debug_print("‚úÖ FFmpeg ƒë√£ s·∫µn s√†ng:")
    debug_print(result.stdout.split('\n')[0])  # Ch·ªâ hi·ªÉn th·ªã d√≤ng ƒë·∫ßu ti√™n
except Exception as e:
    debug_print("‚ö†Ô∏è L·ªói khi ch·∫°y ffmpeg:", e)
    debug_print("üìÅ ƒêang t√¨m ffmpeg trong th∆∞ m·ª•c ffmpeg/")

# Ki·ªÉm tra phi√™n b·∫£n yt-dlp


def check_ytdlp_version():
    """Ki·ªÉm tra phi√™n b·∫£n yt-dlp"""
    possible_paths = [
        "yt-dlp.exe",  # Trong th∆∞ m·ª•c hi·ªán t·∫°i
        "yt-dlp",      # Trong PATH (Linux/Mac)
    ]

    for ytdlp_path in possible_paths:
        try:
            result = subprocess.run(
                [ytdlp_path, "--version"], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                version = result.stdout.strip()
                debug_print("‚úÖ yt-dlp ƒë√£ s·∫µn s√†ng:")
                debug_print(f"üì¶ Phi√™n b·∫£n: {version}")
                debug_print(f"üìç ƒê∆∞·ªùng d·∫´n: {ytdlp_path}")
                return ytdlp_path, version
        except subprocess.TimeoutExpired:
            debug_print(f"‚è±Ô∏è Timeout khi ki·ªÉm tra {ytdlp_path}")
        except FileNotFoundError:
            debug_print(f"‚ùå Kh√¥ng t√¨m th·∫•y {ytdlp_path}")
        except Exception as e:
            debug_print(f"‚ö†Ô∏è L·ªói khi ki·ªÉm tra {ytdlp_path}: {e}")

    debug_print("‚ùå Kh√¥ng t√¨m th·∫•y yt-dlp!")
    debug_print("üí° H∆∞·ªõng d·∫´n c√†i ƒë·∫∑t:")
    debug_print(
        "   1. T·∫£i yt-dlp.exe t·ª´: https://github.com/yt-dlp/yt-dlp/releases")
    debug_print("   2. ƒê·∫∑t file yt-dlp.exe v√†o th∆∞ m·ª•c ch·ª©a App.py")
    debug_print("   3. Ho·∫∑c c√†i ƒë·∫∑t qua pip: pip install yt-dlp")
    return None, None


# G·ªçi ki·ªÉm tra yt-dlp
ytdlp_executable, ytdlp_version = check_ytdlp_version()


class DownloadWorker(QThread):
    """Worker thread ƒë·ªÉ x·ª≠ l√Ω download video"""
    message = Signal(str)
    progress_signal = Signal(int)
    finished = Signal(str)

    def __init__(self, urls, video_mode, audio_only, sub_mode, sub_lang,
                 convert_srt, include_thumb, subtitle_only, custom_folder_name=""):
        super().__init__()
        self.urls = urls
        self.video_mode = video_mode
        self.audio_only = audio_only
        self.sub_mode = sub_mode
        self.sub_lang = sub_lang
        self.convert_srt = convert_srt
        self.include_thumb = include_thumb
        self.subtitle_only = subtitle_only
        self.custom_folder_name = custom_folder_name.strip()
        self.stop_flag = False
        self.process = None

    def stop(self):
        """D·ª´ng qu√° tr√¨nh download"""
        self.stop_flag = True
        if self.process:
            self.process.terminate()
            self.message.emit("‚èπ D·ª´ng t·∫£i...")

    def run(self):
        """Ch·∫°y qu√° tr√¨nh download"""
        try:
            download_folder = self._create_download_folder()
            download_folder = download_folder.replace('\\', '/')
            for i, url in enumerate(self.urls, 1):
                if self.stop_flag:
                    self.message.emit("‚èπ ƒê√£ d·ª´ng t·∫£i.")
                    break

                self.message.emit(f"üîó [{i}] ƒêang t·∫£i: {url}")

                if self._download_single_url(url, download_folder, i):
                    self.message.emit(f"‚úÖ Ho√†n th√†nh link URL: {url}")
                else:
                    self.message.emit(f"‚ùå L·ªói khi t·∫£i link: {url}")

                self.progress_signal.emit(int(i / len(self.urls) * 100))

            self.finished.emit(f"üìÇ Video ƒë∆∞·ª£c l∆∞u t·∫°i: {download_folder}")

        except Exception as e:
            self.message.emit(f"‚ùå L·ªói: {e}")

    def _create_download_folder(self):
        """T·∫°o th∆∞ m·ª•c download v·ªõi c·∫•u tr√∫c ƒë∆°n gi·∫£n"""
        base_folder = "Video"
        os.makedirs(base_folder, exist_ok=True)
        
        if self.custom_folder_name:
            # N·∫øu c√≥ t√™n th∆∞ m·ª•c t√πy ch·ªçn
            if os.path.isabs(self.custom_folder_name):
                # ƒê∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß
                date_folder = self.custom_folder_name
            else:
                # T√™n th∆∞ m·ª•c - t·∫°o trong th∆∞ m·ª•c Video
                date_folder = os.path.join(base_folder, self.custom_folder_name)
        else:
            # Kh√¥ng c√≥ t√™n t√πy ch·ªçn - t·∫°o theo ng√†y
            date_str = datetime.now().strftime("%Y-%m-%d")
            date_folder = os.path.join(base_folder, date_str)
        
        # T·∫°o th∆∞ m·ª•c con v·ªõi s·ªë th·ª© t·ª± (01, 02, 03...)
        download_folder = self._create_numbered_subfolder(date_folder)
        
        os.makedirs(download_folder, exist_ok=True)
        return download_folder
    
    def _create_numbered_subfolder(self, date_folder):
        """T·∫°o th∆∞ m·ª•c con v·ªõi s·ªë th·ª© t·ª± (01, 02, 03...)"""
        if not os.path.exists(date_folder):
            os.makedirs(date_folder, exist_ok=True)
        
        # T√¨m s·ªë th·ª© t·ª± cao nh·∫•t trong th∆∞ m·ª•c ng√†y
        max_number = 0
        for item in os.listdir(date_folder):
            item_path = os.path.join(date_folder, item)
            if os.path.isdir(item_path) and item.isdigit():
                max_number = max(max_number, int(item))
        
        # T·∫°o th∆∞ m·ª•c con m·ªõi v·ªõi s·ªë ti·∫øp theo (format 2 ch·ªØ s·ªë)
        next_number = max_number + 1
        subfolder_name = f"{next_number:02d}"
        download_folder = os.path.join(date_folder, subfolder_name)
        
        return download_folder

    def _download_single_url(self, url, download_folder, index):
        """Download m·ªôt URL ƒë∆°n"""
        cmd = self._build_command(url, download_folder, index)

        # Thi·∫øt l·∫≠p creation flags ƒë·ªÉ ·∫©n console window tr√™n Windows
        creation_flags = 0
        if sys.platform == "win32":
            creation_flags = subprocess.CREATE_NO_WINDOW

        self.process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, bufsize=1, creationflags=creation_flags
        )

        for line in self.process.stdout:
            if self.stop_flag:
                self.process.terminate()
                self.message.emit("‚èπ ƒêang d·ª´ng...")
                break

            line = line.strip()
            if line:
                self.message.emit(line)
                self._update_progress_from_line(line)

        self.process.wait()

        if self.process.returncode == 0:
            self._post_process_files(download_folder)
            return True
        return False

    def _build_command(self, url, download_folder, index):
        """X√¢y d·ª±ng l·ªánh yt-dlp"""
        # S·ª≠ d·ª•ng yt-dlp ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra t·ª´ tr∆∞·ªõc
        global ytdlp_executable
        if ytdlp_executable:
            ytdlp_path = ytdlp_executable
        else:
            # Fallback - t√¨m l·∫°i n·∫øu c·∫ßn
            ytdlp_path = None
            possible_paths = [
                "yt-dlp.exe",  # Trong PATH
                "yt-dlp",      # Fallback cho Linux/Mac
            ]

            for path in possible_paths:
                if os.path.exists(path):
                    ytdlp_path = path
                    break

            if not ytdlp_path:
                # Fallback to system yt-dlp
                ytdlp_path = "yt-dlp"

        cmd = [ytdlp_path, url, "--progress"]

        # Th√™m ƒë∆∞·ªùng d·∫´n ffmpeg n·∫øu t·ªìn t·∫°i
        if os.path.exists(ffmpeg_path):
            cmd += ["--ffmpeg-location", ffmpeg_path]

        if self.subtitle_only:
            cmd.append("--skip-download")
            self.message.emit("üìù Ch·∫ø ƒë·ªô: Ch·ªâ t·∫£i ph·ª• ƒë·ªÅ")
        else:
            cmd += ["-f", "bv*+ba/b", "--merge-output-format", "mp4"]

        # Template output
        if self.video_mode:
            output_template = "%(title)s.%(ext)s"
        else:
            output_template = f"%(autonumber)03d_%(title)s.%(ext)s"
            cmd.append("--yes-playlist")

        cmd += ["-o", os.path.join(download_folder, output_template)]

        if self.audio_only and not self.subtitle_only:
            cmd += ["--extract-audio", "--audio-format", "mp3"]

        # X·ª≠ l√Ω ph·ª• ƒë·ªÅ
        if self.sub_mode != "‚ùå Kh√¥ng t·∫£i":
            self._add_subtitle_options(cmd)

        if self.convert_srt:
            cmd += ["--convert-subs", "srt"]
        if self.include_thumb:
            cmd.append("--write-thumbnail")

        return cmd

    def _add_subtitle_options(self, cmd):
        """Th√™m t√πy ch·ªçn ph·ª• ƒë·ªÅ v√†o l·ªánh"""
        # sub_lang b√¢y gi·ªù l√† string ƒë∆°n thay v√¨ list
        lang_string = self.sub_lang
        lang_display = self.sub_lang

        if self.sub_mode == "üìÑ Ph·ª• ƒë·ªÅ ch√≠nh th·ª©c":
            cmd += ["--write-subs", "--sub-langs", lang_string]
            self.message.emit(
                f"üî§ T·∫£i ph·ª• ƒë·ªÅ ch√≠nh th·ª©c cho ng√¥n ng·ªØ: {lang_display}")
        elif self.sub_mode == "ü§ñ Ph·ª• ƒë·ªÅ t·ª± ƒë·ªông":
            cmd += ["--write-auto-subs", "--sub-langs", lang_string]
            self.message.emit(
                f"ü§ñ T·∫£i ph·ª• ƒë·ªÅ t·ª± ƒë·ªông cho ng√¥n ng·ªØ: {lang_display}")

        # Th√™m c√°c t√πy ch·ªçn ƒë·ªÉ ƒë·∫£m b·∫£o t·∫£i ƒë∆∞·ª£c ph·ª• ƒë·ªÅ
        cmd += [
            "--ignore-errors",           # B·ªè qua l·ªói n·∫øu m·ªôt ng√¥n ng·ªØ kh√¥ng c√≥
            "--no-warnings",            # Kh√¥ng hi·ªÉn th·ªã c·∫£nh b√°o
            "--sub-format", "srt/best"  # ∆Øu ti√™n ƒë·ªãnh d·∫°ng SRT
        ]

        # Debug: In ra l·ªánh ph·ª• ƒë·ªÅ
        self.message.emit(f"üîß Debug: L·ªánh ph·ª• ƒë·ªÅ = --sub-langs {lang_string}")

    def _update_progress_from_line(self, line):
        """C·∫≠p nh·∫≠t progress t·ª´ output line"""
        if "%" in line:
            try:
                percent_str = line.split(
                    "%", 1)[0].split()[-1].replace(".", "").strip()
                percent = int(percent_str)
                if 0 <= percent <= 100:
                    self.progress_signal.emit(percent)
            except:
                pass

    def _post_process_files(self, download_folder):
        """X·ª≠ l√Ω files sau khi download"""
        if self.sub_mode != "‚ùå Kh√¥ng t·∫£i":
            # sub_lang b√¢y gi·ªù l√† string ƒë∆°n
            self.message.emit(f"üîÑ X·ª≠ l√Ω ph·ª• ƒë·ªÅ cho ng√¥n ng·ªØ: {self.sub_lang}")
            self._rename_subtitle_files(download_folder, self.sub_lang)

        self._rename_video_files(download_folder)

    def _rename_subtitle_files(self, folder_path, sub_lang):
        """ƒê·ªïi t√™n file ph·ª• ƒë·ªÅ theo ƒë·ªãnh d·∫°ng mong mu·ªën"""
        try:
            self.message.emit(f"üîß ƒêang x·ª≠ l√Ω ph·ª• ƒë·ªÅ ng√¥n ng·ªØ: {sub_lang}")

            # T√¨m t·∫•t c·∫£ file ph·ª• ƒë·ªÅ cho ng√¥n ng·ªØ n√†y
            patterns = [
                f"*.{sub_lang}.srt",
                f"*.{sub_lang}.vtt",
                f"*.{sub_lang}.ass"
            ]

            found_files = []
            for pattern in patterns:
                found_files.extend(
                    glob.glob(os.path.join(folder_path, pattern)))

            if not found_files:
                self.message.emit(
                    f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file ph·ª• ƒë·ªÅ cho ng√¥n ng·ªØ: {sub_lang}")
                return

            self.message.emit(
                f"üìÅ T√¨m th·∫•y {len(found_files)} file ph·ª• ƒë·ªÅ cho {sub_lang}")

            for subtitle_file in found_files:
                filename = os.path.basename(subtitle_file)

                if sub_lang == "en":
                    # X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho ti·∫øng Anh - ƒë·ªïi th√†nh .srt ch√≠nh
                    if subtitle_file.endswith(".en.srt"):
                        # print(f"üîç ƒêang x·ª≠ l√Ω1 : {subtitle_file}")
                        new_name = subtitle_file.replace(
                            "..en.srt", ".srt").replace(".en.srt", ".srt")
                        # print(f"üîç ƒêang x·ª≠ l√Ω: {new_name}")
                        if not os.path.exists(new_name):
                            os.rename(subtitle_file, new_name)
                            self.message.emit(
                                f"üìù ƒê·ªïi t√™n: {filename} ‚Üí {os.path.basename(new_name)}")
                        else:
                            self.message.emit(
                                f"‚ö†Ô∏è File ƒë√£ t·ªìn t·∫°i: {os.path.basename(new_name)}")

                # S·ª≠a l·ªói t√™n file c√≥ .. (double dots)
                if f"..{sub_lang}." in subtitle_file:
                    ext = os.path.splitext(subtitle_file)[1]
                    new_name = subtitle_file.replace(
                        f"..{sub_lang}.", f".{sub_lang}.")
                    if not os.path.exists(new_name) and new_name != subtitle_file:
                        os.rename(subtitle_file, new_name)
                        self.message.emit(
                            f"üìù S·ª≠a t√™n: {filename} ‚Üí {os.path.basename(new_name)}")

        except Exception as e:
            self.message.emit(f"‚ö†Ô∏è L·ªói ƒë·ªïi t√™n ph·ª• ƒë·ªÅ {sub_lang}: {e}")

    def _rename_video_files(self, folder_path):
        """ƒê·ªïi t√™n file video (s·ª≠a ..mp4, ..mp3, etc. th√†nh .mp4, .mp3)"""
        try:
            video_formats = ["*.mp4", "*.mp3",
                             "*.mkv", "*.avi", "*.mov", "*.webm"]

            for format_pattern in video_formats:
                for media_file in glob.glob(os.path.join(folder_path, format_pattern)):
                    filename = os.path.basename(media_file)

                    if ".." in filename:
                        file_ext = os.path.splitext(filename)[1]
                        new_filename = filename.replace(
                            f"..{file_ext[1:]}", file_ext)
                        new_path = os.path.join(folder_path, new_filename)

                        if not os.path.exists(new_path):
                            os.rename(media_file, new_path)
                            self.message.emit(
                                f"üìù S·ª≠a t√™n: {filename} ‚Üí {new_filename}")

        except Exception as e:
            self.message.emit(f"‚ö†Ô∏è L·ªói ƒë·ªïi t√™n file media: {e}")


class DownloaderApp(QWidget):
    """·ª®ng d·ª•ng ch√≠nh ƒë·ªÉ download video"""

    def __init__(self):
        super().__init__()
        self.worker = None
        self.update_checker = None  # Update checker thread
        self.settings = QSettings("HT Software", "DownloadVID")
        self.loading_settings = False  # Flag ƒë·ªÉ tr√°nh auto-save khi ƒëang load
        self.init_ui()
        self.apply_styles()
        self.load_settings()

        # Hi·ªÉn th·ªã th√¥ng tin phi√™n b·∫£n khi kh·ªüi ƒë·ªông
        self._show_startup_info()

        # Ki·ªÉm tra update t·ª± ƒë·ªông khi kh·ªüi ƒë·ªông (sau 3 gi√¢y)
        QTimer.singleShot(3000, self.auto_check_update)

    def _show_startup_info(self):
        """Hi·ªÉn th·ªã th√¥ng tin phi√™n b·∫£n khi kh·ªüi ƒë·ªông"""
        global ytdlp_executable, ytdlp_version

        # Ki·ªÉm tra xem c√≥ v·ª´a c·∫≠p nh·∫≠t kh√¥ng
        self._check_recent_update()

        # Th√¥ng tin c∆° b·∫£n
        app_info = f"üé¨ HT DownloadVID v{APP_VERSION} - Kh·ªüi ƒë·ªông th√†nh c√¥ng!"
        debug_print(app_info)

        # Hi·ªÉn th·ªã th√¥ng tin trong log output c·ªßa ·ª©ng d·ª•ng
        self.output_list.addItem("=" * 50)
        self.output_list.addItem(f"üé¨ HT DownloadVID v{APP_VERSION}")
        self.output_list.addItem("=" * 50)

        # Th√¥ng tin yt-dlp
        if ytdlp_executable and ytdlp_version:
            self.output_list.addItem(f"‚úÖ yt-dlp: {ytdlp_version}")
            self.output_list.addItem(f"üìç ƒê∆∞·ªùng d·∫´n: {ytdlp_executable}")
        else:
            self.output_list.addItem("‚ùå yt-dlp: Kh√¥ng t√¨m th·∫•y!")
            self.output_list.addItem("‚ö†Ô∏è ·ª®ng d·ª•ng c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông ƒë√∫ng")

        # Th√¥ng tin ffmpeg
        if os.path.exists(ffmpeg_path):
            self.output_list.addItem("‚úÖ ffmpeg: ƒê√£ s·∫µn s√†ng")
            self.output_list.addItem(f"üìç ƒê∆∞·ªùng d·∫´n: {ffmpeg_path}")
        else:
            self.output_list.addItem("‚ö†Ô∏è ffmpeg: Kh√¥ng t√¨m th·∫•y")

        self.output_list.addItem("=" * 50)
        self.output_list.addItem("üí° S·∫µn s√†ng t·∫£i video!")
        self.output_list.addItem("")

        # Cu·ªôn xu·ªëng cu·ªëi
        self.scroll_to_bottom()

    def _check_recent_update(self):
        """Ki·ªÉm tra xem c√≥ v·ª´a c·∫≠p nh·∫≠t kh√¥ng"""
        global APP_VERSION

        try:
            version_file = os.path.join(os.getcwd(), "version.txt")
            if os.path.exists(version_file):
                with open(version_file, 'r', encoding='utf-8') as f:
                    updated_version = f.read().strip()

                # N·∫øu phi√™n b·∫£n trong file kh√°c v·ªõi APP_VERSION hi·ªán t·∫°i
                if updated_version and updated_version != APP_VERSION:
                    # Hi·ªÉn th·ªã th√¥ng b√°o c·∫≠p nh·∫≠t th√†nh c√¥ng
                    QTimer.singleShot(
                        1000, lambda: self._show_update_success_message(updated_version))

                    # C·∫≠p nh·∫≠t APP_VERSION trong runtime
                    old_version = APP_VERSION
                    APP_VERSION = updated_version

                    debug_print(
                        f"üéâ C·∫≠p nh·∫≠t th√†nh c√¥ng t·ª´ v{old_version} l√™n v{APP_VERSION}")

                    # X√≥a file version.txt sau khi ƒë√£ x·ª≠ l√Ω
                    os.remove(version_file)

        except Exception as e:
            debug_print(f"‚ö†Ô∏è L·ªói ki·ªÉm tra phi√™n b·∫£n m·ªõi: {e}")

    def _show_update_success_message(self, new_version):
        """Hi·ªÉn th·ªã th√¥ng b√°o c·∫≠p nh·∫≠t th√†nh c√¥ng"""
        QMessageBox.information(
            self,
            "üéâ C·∫≠p nh·∫≠t th√†nh c√¥ng!",
            f"‚úÖ ·ª®ng d·ª•ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng!\n\n"
            f"üîÑ Phi√™n b·∫£n m·ªõi: v{new_version}\n"
            f"üöÄ ·ª®ng d·ª•ng ƒë√£ s·∫µn s√†ng s·ª≠ d·ª•ng v·ªõi c√°c t√≠nh nƒÉng m·ªõi!\n\n"
            f"C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng HT DownloadVID! üíñ"
        )

    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán ng∆∞·ªùi d√πng"""
        self.setWindowTitle(f"HT DownloadVID v{APP_VERSION}")

        # Thi·∫øt l·∫≠p icon cho c·ª≠a s·ªï
        icon_path = resource_path("ico.ico")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        self.setMinimumWidth(520)
        self.center_window()

        # T·∫°o layout ch√≠nh
        main_layout = QVBoxLayout()
        self.setLayout(main_layout)

        # Th√™m menubar
        self._create_menubar()
        main_layout.addWidget(self.menubar)

        # T·∫°o layout cho n·ªôi dung ch√≠nh
        self.layout = QVBoxLayout()
        main_layout.addLayout(self.layout)

        self._create_url_section()
        self._create_mode_section()
        self._create_subtitle_section()
        self._create_options_section()
        self._create_control_buttons()
        self._create_progress_section()
        self._create_log_section()

        # Auto-save s·∫Ω ƒë∆∞·ª£c k·∫øt n·ªëi sau khi load_settings() ho√†n th√†nh

    def _create_menubar(self):
        """T·∫°o menubar"""
        self.menubar = QMenuBar(self)

        # Menu File
        file_menu = self.menubar.addMenu("üìÅ File")

        # Action Reset Settings
        reset_action = QAction("üîÑ Reset Settings", self)
        reset_action.triggered.connect(self.reset_settings)
        file_menu.addAction(reset_action)

        file_menu.addSeparator()

        # Action Exit
        exit_action = QAction("‚ùå Exit", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Menu Settings
        settings_menu = self.menubar.addMenu("‚öôÔ∏è Settings")

        # Action Save Current Settings
        save_settings_action = QAction("üíæ Save Current Settings", self)
        save_settings_action.triggered.connect(self.save_settings)
        settings_menu.addAction(save_settings_action)

        # Action Load Default Settings
        load_default_action = QAction("üìã Load Default Settings", self)
        load_default_action.triggered.connect(self.load_default_settings)
        settings_menu.addAction(load_default_action)

        settings_menu.addSeparator()

        # Action View Settings Info
        info_action = QAction("üìä View Settings Info", self)
        info_action.triggered.connect(self.show_settings_info)
        settings_menu.addAction(info_action)

        # Menu Help
        help_menu = self.menubar.addMenu("‚ùì Help")

        # Action Check for Updates
        update_action = QAction("üîÑ Check for Updates", self)
        update_action.triggered.connect(self.manual_check_update)
        help_menu.addAction(update_action)

        help_menu.addSeparator()

        # Action Check Tool Versions
        version_action = QAction("üîß Check Tool Versions", self)
        version_action.triggered.connect(self.check_tool_versions)
        help_menu.addAction(version_action)

        help_menu.addSeparator()

        # Action View Log File
        log_action = QAction("üìù View Log File", self)
        log_action.triggered.connect(self.show_log_file)
        help_menu.addAction(log_action)

        help_menu.addSeparator()

        # Action About
        about_action = QAction("‚ÑπÔ∏è About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

    def _create_url_section(self):
        """T·∫°o ph·∫ßn nh·∫≠p URL"""
        self.layout.addWidget(QLabel("üìã Nh·∫≠p URL video:"))

        self.url_input = QTextEdit()
        self.url_input.setPlaceholderText(
            "M·ªói d√≤ng 1 link video ho·∫∑c playlist...")
        self.url_input.setFixedHeight(75)
        self.layout.addWidget(self.url_input)

        self.layout.addWidget(QLabel("üìÅ T√™n th∆∞ m·ª•c t·∫£i (tu·ª≥ ch·ªçn):"))

        # T·∫°o layout ngang cho √¥ nh·∫≠p t√™n th∆∞ m·ª•c v√† n√∫t ch·ªçn th∆∞ m·ª•c
        folder_layout = QHBoxLayout()

        self.folder_name_input = QTextEdit()
        self.folder_name_input.setPlaceholderText(
            "Nh·∫≠p t√™n th∆∞ m·ª•c ho·∫∑c ch·ªçn th∆∞ m·ª•c...")
        self.folder_name_input.setFixedHeight(45)
        folder_layout.addWidget(self.folder_name_input)

        # N√∫t ch·ªçn th∆∞ m·ª•c
        self.browse_folder_button = QPushButton("üìÇ Open")
        self.browse_folder_button.clicked.connect(self.browse_folder)
        self.browse_folder_button.setFixedWidth(130)
        folder_layout.addWidget(self.browse_folder_button)

        self.layout.addLayout(folder_layout)

    def _create_mode_section(self):
        """T·∫°o ph·∫ßn ch·ªçn ch·∫ø ƒë·ªô t·∫£i"""
        self.mode_group = QButtonGroup(self)
        self.video_radio = QRadioButton("üé¨ Video ƒë∆°n")
        self.playlist_radio = QRadioButton("üìÉ Playlist")
        self.video_radio.setChecked(True)

        mode_layout = QHBoxLayout()
        mode_layout.addWidget(self.video_radio)
        mode_layout.addWidget(self.playlist_radio)

        self.mode_group.addButton(self.video_radio)
        self.mode_group.addButton(self.playlist_radio)
        self.layout.addLayout(mode_layout)

    def _create_subtitle_section(self):
        """T·∫°o ph·∫ßn t√πy ch·ªçn ph·ª• ƒë·ªÅ"""
        self.layout.addWidget(QLabel("üìù T√πy ch·ªçn ph·ª• ƒë·ªÅ:"))

        # T·∫°o layout ngang cho ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ v√† ng√¥n ng·ªØ
        subtitle_layout = QHBoxLayout()

        # Ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ
        subtitle_layout.addWidget(QLabel("Ch·∫ø ƒë·ªô:"))
        self.sub_mode = QComboBox()
        self.sub_mode.addItems([
            "‚ùå Kh√¥ng t·∫£i",
            "üìÑ Ph·ª• ƒë·ªÅ ch√≠nh th·ª©c",
            "ü§ñ Ph·ª• ƒë·ªÅ t·ª± ƒë·ªông"
        ])
        self.sub_mode.setCurrentText("ü§ñ Ph·ª• ƒë·ªÅ t·ª± ƒë·ªông")
        subtitle_layout.addWidget(self.sub_mode)

        # Ng√¥n ng·ªØ ph·ª• ƒë·ªÅ
        subtitle_layout.addWidget(QLabel("Ng√¥n ng·ªØ:"))
        self.sub_lang = QComboBox()
        self.sub_lang.addItems([
            "üáªüá≥ Ti·∫øng Vi·ªát (vi)",
            "üá∫üá∏ Ti·∫øng Anh (en)",
            "üá®üá≥ Ti·∫øng Trung Gi·∫£n th·ªÉ (zh-Hans)",
            "üáπüáº Ti·∫øng Trung Ph·ªìn th·ªÉ (zh-Hant)",
            "üá∞üá∑ Ti·∫øng H√†n (ko)",
            "üáØüáµ Ti·∫øng Nh·∫≠t (ja)",
            "üá´üá∑ Ti·∫øng Ph√°p (fr)",
            "üá™üá∏ Ti·∫øng T√¢y Ban Nha (es)"
        ])
        self.sub_lang.setCurrentText("üáªüá≥ Ti·∫øng Vi·ªát (vi)")
        subtitle_layout.addWidget(self.sub_lang)

        self.layout.addLayout(subtitle_layout)

    def _get_selected_language_code(self):
        """L·∫•y m√£ ng√¥n ng·ªØ t·ª´ combobox ƒë√£ ch·ªçn"""
        selected_text = self.sub_lang.currentText()
        # Extract language code t·ª´ text (v√≠ d·ª•: "üáªüá≥ Ti·∫øng Vi·ªát (vi)" -> "vi")
        if "(" in selected_text and ")" in selected_text:
            return selected_text.split("(")[-1].split(")")[0]
        return "vi"  # Default fallback

    def _create_options_section(self):
        """T·∫°o ph·∫ßn t√πy ch·ªçn b·ªï sung"""
        # D√≤ng 1: Chuy·ªÉn ph·ª• ƒë·ªÅ sang .srt v√† T·∫£i √¢m thanh MP3
        row1_layout = QHBoxLayout()

        self.convert_srt = QCheckBox("üîÅ Chuy·ªÉn ph·ª• ƒë·ªÅ sang .srt")
        self.convert_srt.setChecked(True)
        row1_layout.addWidget(self.convert_srt)

        self.audio_only = QCheckBox("üéµ T·∫£i √¢m thanh MP3")
        row1_layout.addWidget(self.audio_only)

        row1_layout.addStretch()  # Th√™m kho·∫£ng tr·ªëng ƒë·ªÉ cƒÉn tr√°i
        self.layout.addLayout(row1_layout)

        # D√≤ng 2: T·∫£i ·∫£nh thumbnail v√† Ch·ªâ t·∫£i ph·ª• ƒë·ªÅ
        row2_layout = QHBoxLayout()

        self.include_thumb = QCheckBox("üñºÔ∏è T·∫£i ·∫£nh thumbnail")
        row2_layout.addWidget(self.include_thumb)

        self.subtitle_only = QCheckBox("üìù Ch·ªâ t·∫£i ph·ª• ƒë·ªÅ")
        row2_layout.addWidget(self.subtitle_only)

        row2_layout.addStretch()  # Th√™m kho·∫£ng tr·ªëng ƒë·ªÉ cƒÉn tr√°i
        self.layout.addLayout(row2_layout)

    def _create_control_buttons(self):
        """T·∫°o c√°c n√∫t ƒëi·ªÅu khi·ªÉn"""
        self.download_button = QPushButton("üöÄ B·∫Øt ƒë·∫ßu t·∫£i")
        self.download_button.clicked.connect(self.start_download)

        self.stop_button = QPushButton("‚èπ D·ª´ng t·∫£i")
        self.stop_button.clicked.connect(self.stop_download)
        self.stop_button.setVisible(False)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.download_button)
        button_layout.addWidget(self.stop_button)
        self.layout.addLayout(button_layout)

    def _create_progress_section(self):
        """T·∫°o thanh ti·∫øn tr√¨nh"""
        self.progress = QProgressBar()
        self.progress.setVisible(False)
        self.layout.addWidget(self.progress)

    def _create_log_section(self):
        """T·∫°o ph·∫ßn log"""
        self.output_list = QListWidget()
        self.output_list.setWordWrap(True)
        self.output_list.setHorizontalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.output_list.setVerticalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.output_list.setMinimumHeight(120)
        self.layout.addWidget(self.output_list)

    def _connect_auto_save(self):
        """K·∫øt n·ªëi auto-save v·ªõi c√°c control"""
        # Ch·ªâ k·∫øt n·ªëi sau khi ƒë√£ load settings xong
        if not hasattr(self, 'loading_settings') or self.loading_settings:
            return

        # URL input
        self.url_input.textChanged.connect(self.auto_save_on_change)

        # Folder input
        self.folder_name_input.textChanged.connect(self.auto_save_on_change)

        # Radio buttons
        self.video_radio.toggled.connect(self.auto_save_on_change)
        self.playlist_radio.toggled.connect(self.auto_save_on_change)

        # Combobox
        self.sub_mode.currentTextChanged.connect(self.auto_save_on_change)
        self.sub_lang.currentTextChanged.connect(self.auto_save_on_change)

        # Checkboxes
        self.convert_srt.toggled.connect(self.auto_save_on_change)
        self.audio_only.toggled.connect(self.auto_save_on_change)
        self.include_thumb.toggled.connect(self.auto_save_on_change)
        self.subtitle_only.toggled.connect(self.auto_save_on_change)

        # Language checkboxes ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi trong _create_language_checkboxes()
        # Kh√¥ng c·∫ßn k·∫øt n·ªëi l·∫°i ·ªü ƒë√¢y

    def center_window(self):
        """CƒÉn gi·ªØa c·ª≠a s·ªï tr√™n m√†n h√¨nh"""
        self.resize(520, 700)

        screen = QApplication.primaryScreen()
        if screen:
            screen_geometry = screen.availableGeometry()
            window_geometry = self.frameGeometry()
            center_point = screen_geometry.center()
            window_geometry.moveCenter(center_point)
            self.move(window_geometry.topLeft())

    def start_download(self):
        """B·∫Øt ƒë·∫ßu qu√° tr√¨nh download"""
        urls = [u.strip()
                for u in self.url_input.toPlainText().splitlines() if u.strip()]
        if not urls:
            QMessageBox.warning(self, "C·∫£nh b√°o", "B·∫°n ch∆∞a nh·∫≠p URL n√†o.")
            return

        self._prepare_ui_for_download()

        # L·∫•y ng√¥n ng·ªØ ƒë√£ ch·ªçn t·ª´ combobox
        selected_lang_code = self._get_selected_language_code()

        # Debug: Hi·ªÉn th·ªã th√¥ng tin c·∫•u h√¨nh chi ti·∫øt
        self.output_list.addItem("üîß === TH√îNG TIN C·∫§U H√åNH ===")
        self.output_list.addItem(f"üîó S·ªë URL: {len(urls)}")
        self.output_list.addItem(
            f"üé¨ Ch·∫ø ƒë·ªô: {'Video ƒë∆°n' if self.video_radio.isChecked() else 'Playlist'}")
        self.output_list.addItem(f"üìù Ph·ª• ƒë·ªÅ: {self.sub_mode.currentText()}")
        self.output_list.addItem(
            f"üåç Ng√¥n ng·ªØ ph·ª• ƒë·ªÅ: {self.sub_lang.currentText()}")

        # Hi·ªÉn th·ªã c√°c t√πy ch·ªçn kh√°c
        options = []
        if self.audio_only.isChecked():
            options.append("üéµ Audio MP3")
        if self.convert_srt.isChecked():
            options.append("üîÅ Convert SRT")
        if self.include_thumb.isChecked():
            options.append("üñºÔ∏è Thumbnail")
        if self.subtitle_only.isChecked():
            options.append("üìù Ch·ªâ ph·ª• ƒë·ªÅ")

        if options:
            self.output_list.addItem(f"‚öôÔ∏è T√πy ch·ªçn: {', '.join(options)}")

        custom_folder = self.folder_name_input.toPlainText().strip()
        if custom_folder:
            self.output_list.addItem(f"üìÅ Th∆∞ m·ª•c: {custom_folder}")

        self.output_list.addItem("üîß ========================")
        self.scroll_to_bottom()

        self.worker = DownloadWorker(
            urls=urls,
            video_mode=self.video_radio.isChecked(),
            audio_only=self.audio_only.isChecked(),
            sub_mode=self.sub_mode.currentText(),
            sub_lang=selected_lang_code,  # Truy·ªÅn string thay v√¨ list
            convert_srt=self.convert_srt.isChecked(),
            include_thumb=self.include_thumb.isChecked(),
            subtitle_only=self.subtitle_only.isChecked(),
            custom_folder_name=custom_folder
        )

        self._connect_worker_signals()
        self.worker.start()

    def _prepare_ui_for_download(self):
        """Chu·∫©n b·ªã UI cho qu√° tr√¨nh download"""
        self.output_list.clear()
        self.progress.setValue(0)
        self.stop_button.setVisible(True)
        self.progress.setVisible(True)
        self.download_button.setEnabled(False)
        # self.output_list.setMinimumHeight(120)

    def _connect_worker_signals(self):
        """K·∫øt n·ªëi c√°c signal c·ªßa worker"""
        self.worker.message.connect(self.output_list.addItem)
        self.worker.message.connect(self.scroll_to_bottom)
        self.worker.progress_signal.connect(self.progress.setValue)
        self.worker.finished.connect(self.output_list.addItem)
        self.worker.finished.connect(self.scroll_to_bottom)
        self.worker.finished.connect(self.on_download_finished)

    def stop_download(self):
        """D·ª´ng qu√° tr√¨nh download"""
        if self.worker and self.worker.isRunning():
            self.worker.stop()
            self.output_list.addItem("‚èπ ƒêang d·ª´ng ti·∫øn tr√¨nh...")
            self.scroll_to_bottom()
            self._reset_ui_after_download()
        else:
            QMessageBox.information(
                self, "Th√¥ng b√°o", "Hi·ªán kh√¥ng c√≥ t√°c v·ª• n√†o ƒëang ch·∫°y.")

    def on_download_finished(self):
        """X·ª≠ l√Ω khi download ho√†n th√†nh"""
        self._reset_ui_after_download()

    def _reset_ui_after_download(self):
        """Reset UI sau khi download xong ho·∫∑c d·ª´ng"""
        self.stop_button.setVisible(False)
        self.progress.setVisible(False)
        self.download_button.setEnabled(True)
        # self.output_list.setMinimumHeight(120)

    def scroll_to_bottom(self):
        """Cu·ªôn xu·ªëng cu·ªëi danh s√°ch"""
        self.output_list.scrollToBottom()

    def apply_styles(self):
        """√Åp d·ª•ng stylesheet"""
        self.setStyleSheet("""
            QWidget {
                background-color: #f8f9fa;
                font-size: 13px;
                font-family: "Segoe UI", Arial, sans-serif;
                color: #212529;
            }
            QPushButton {
                background-color: #28a745;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #218838;
            }
            QPushButton:pressed {
                background-color: #1e7e34;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                color: #ffffff;
            }
            QProgressBar {
                border: 2px solid #dee2e6;
                border-radius: 6px;
                text-align: center;
                height: 20px;
                background-color: #e9ecef;
                color: #495057;
                font-weight: bold;
            }
            QProgressBar::chunk {
                background-color: #28a745;
                border-radius: 4px;
            }
            QListWidget {
                background-color: #2d3748;
                color: #e2e8f0;
                border: 2px solid #4a5568;
                border-radius: 6px;
                font-family: "Consolas", "Monaco", monospace;
                font-size: 12px;
                padding: 8px;
                selection-background-color: #4299e1;
                outline: none;
            }
            QListWidget::item {
                padding: 6px 8px;
                border-bottom: 1px solid #4a5568;
                min-height: 20px;
                word-wrap: break-word;
            }
            QListWidget::item:hover {
                background-color: #4a5568;
            }
            QListWidget::item:selected {
                background-color: #4299e1;
                color: #ffffff;
            }
            QTextEdit {
                background-color: #ffffff;
                border: 2px solid #ced4da;
                border-radius: 6px;
                padding: 8px;
                color: #495057;
                font-size: 13px;
            }
            QTextEdit:focus {
                border-color: #80bdff;
                outline: none;
            }
            QComboBox {
                background-color: #ffffff;
                border: 2px solid #ced4da;
                border-radius: 8px;
                padding: 10px 15px;
                color: #495057;
                font-size: 13px;
                font-weight: 500;
                min-height: 20px;
            }
            QComboBox:hover {
                border-color: #80bdff;
                background-color: #f8f9fa;
            }
            QComboBox:focus {
                border-color: #007bff;
                outline: none;
            }
            QLabel {
                color: #343a40;
                font-weight: 500;
                font-size: 13px;
                margin: 5px 0px;
            }
            QCheckBox {
                color: #495057;
                font-size: 13px;
                spacing: 8px;
                padding: 5px;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #ced4da;
                border-radius: 3px;
                background-color: #ffffff;
            }
            QCheckBox::indicator:hover {
                border-color: #007bff;
                background-color: #f8f9fa;
            }
            QCheckBox::indicator:checked {
                background-color: #28a745;
                border-color: #28a745;
            }
            QRadioButton {
                color: #495057;
                font-size: 13px;
                spacing: 8px;
                padding: 5px;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #ced4da;
                border-radius: 9px;
                background-color: #ffffff;
            }
            QRadioButton::indicator:hover {
                border-color: #007bff;
                background-color: #f8f9fa;
            }
            QRadioButton::indicator:checked {
                background-color: #28a745;
                border-color: #28a745;
            }
            #lang-checkbox {
                color: #495057;
                font-size: 11px;
                font-weight: 500;
                spacing: 6px;
                padding: 3px 6px;
                margin: 1px;
                border: 1px solid #e9ecef;
                border-radius: 4px;
                background-color: #f8f9fa;
                max-width: 180px;
            }
            #lang-checkbox:hover {
                background-color: #e9ecef;
                border-color: #007bff;
            }
            #lang-checkbox::indicator {
                width: 14px;
                height: 14px;
                border: 2px solid #ced4da;
                border-radius: 2px;
                background-color: #ffffff;
            }
            #lang-checkbox::indicator:hover {
                border-color: #007bff;
                background-color: #f8f9fa;
            }
            #lang-checkbox::indicator:checked {
                background-color: #007bff;
                border-color: #007bff;
            }
        """)

    def browse_folder(self):
        """M·ªü h·ªôp tho·∫°i ƒë·ªÉ ch·ªçn th∆∞ m·ª•c download"""
        current_text = self.folder_name_input.toPlainText().strip()
        start_dir = current_text if os.path.isdir(
            current_text) else os.getcwd()

        folder_path = QFileDialog.getExistingDirectory(
            self,
            "Ch·ªçn th∆∞ m·ª•c download",
            start_dir
        )

        if folder_path:
            # L∆∞u ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß v√†o input field
            self.folder_name_input.setText(folder_path)
            # T·ª± ƒë·ªông l∆∞u ngay khi ch·ªçn th∆∞ m·ª•c
            self.auto_save_on_change()

    def save_settings(self):
        """L∆∞u settings v√†o registry (v·ªõi th√¥ng b√°o)"""
        try:
            # G·ªçi auto_save_on_change ƒë·ªÉ l∆∞u t·∫•t c·∫£
            self.auto_save_on_change()

            # L∆∞u th√™m th√¥ng tin th·ªëng k√™
            self.settings.setValue("last_saved", datetime.now().isoformat())

            usage_count = self.settings.value("usage_count", 0, int)
            self.settings.setValue("usage_count", usage_count + 1)

            # L∆∞u v·ªã tr√≠ c·ª≠a s·ªï
            self.settings.setValue("geometry", self.saveGeometry())

            # ƒê·ªìng b·ªô
            self.settings.sync()

            QMessageBox.information(
                self, "Th√†nh c√¥ng", "‚úÖ ƒê√£ l∆∞u settings th√†nh c√¥ng!")

        except Exception as e:
            QMessageBox.warning(self, "L·ªói", f"‚ùå Kh√¥ng th·ªÉ l∆∞u settings: {e}")

    def load_settings(self):
        """T·∫£i settings t·ª´ registry"""
        self.loading_settings = True  # T·∫Øt auto-save trong khi load

        try:
            debug_print("üîÑ ƒêang t·∫£i settings...")

            # T·∫£i URL ƒë√£ l∆∞u
            saved_urls = self.settings.value("urls", "")
            if saved_urls:
                self.url_input.setText(saved_urls)
                debug_print(f"üìã ƒê√£ t·∫£i {len(saved_urls.splitlines())} ")

            # T·∫£i t√™n th∆∞ m·ª•c t√πy ch·ªçn
            custom_folder = self.settings.value("custom_folder", "")
            if custom_folder:
                self.folder_name_input.setText(custom_folder)
                debug_print(f"üìÅ ƒê√£ t·∫£i th∆∞ m·ª•c: {custom_folder}")

            # T·∫£i ch·∫ø ƒë·ªô video
            video_mode = self.settings.value("video_mode", True, bool)
            if video_mode:
                self.video_radio.setChecked(True)
            else:
                self.playlist_radio.setChecked(True)
            debug_print(
                f"üé¨ Ch·∫ø ƒë·ªô video: {'Video ƒë∆°n' if video_mode else 'Playlist'}")

            # T·∫£i ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ
            subtitle_mode = self.settings.value(
                "subtitle_mode", "ü§ñ Ph·ª• ƒë·ªÅ t·ª± ƒë·ªông")
            index = self.sub_mode.findText(subtitle_mode)
            if index >= 0:
                self.sub_mode.setCurrentIndex(index)
            debug_print(f"üìù Ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ: {subtitle_mode}")

            # T·∫£i ng√¥n ng·ªØ ph·ª• ƒë·ªÅ
            selected_lang_code = self.settings.value("selected_language", "vi")

            # T√¨m v√† ch·ªçn ng√¥n ng·ªØ trong combobox
            lang_map = {
                "vi": "üáªüá≥ Ti·∫øng Vi·ªát (vi)",
                "en": "üá∫üá∏ Ti·∫øng Anh (en)",
                "zh-Hans": "üá®üá≥ Ti·∫øng Trung Gi·∫£n th·ªÉ (zh-Hans)",
                "zh-Hant": "üáπüáº Ti·∫øng Trung Ph·ªìn th·ªÉ (zh-Hant)",
                "ko": "üá∞üá∑ Ti·∫øng H√†n (ko)",
                "ja": "üáØüáµ Ti·∫øng Nh·∫≠t (ja)",
                "fr": "üá´üá∑ Ti·∫øng Ph√°p (fr)",
                "es": "üá™üá∏ Ti·∫øng T√¢y Ban Nha (es)"
            }

            if selected_lang_code in lang_map:
                self.sub_lang.setCurrentText(lang_map[selected_lang_code])
            debug_print(f"üåç ƒê√£ t·∫£i ng√¥n ng·ªØ: {selected_lang_code}")

            # C·∫≠p nh·∫≠t hi·ªÉn th·ªã ng√¥n ng·ªØ ƒë√£ ch·ªçn
            # self.update_selected_languages_display() is not defined in this class.

            # T·∫£i c√°c t√πy ch·ªçn
            self.convert_srt.setChecked(
                self.settings.value("convert_srt", True, bool))
            self.audio_only.setChecked(
                self.settings.value("audio_only", False, bool))
            self.include_thumb.setChecked(
                self.settings.value("include_thumb", False, bool))
            self.subtitle_only.setChecked(
                self.settings.value("subtitle_only", False, bool))

            # T·∫£i v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc c·ª≠a s·ªï
            geometry = self.settings.value("geometry")
            if geometry:
                self.restoreGeometry(geometry)
                debug_print("ü™ü ƒê√£ kh√¥i ph·ª•c v·ªã tr√≠ c·ª≠a s·ªï")

            # Hi·ªÉn th·ªã th√¥ng tin th·ªëng k√™
            usage_count = self.settings.value("usage_count", 0, int)
            last_saved = self.settings.value("last_saved", "")

            if usage_count > 0:
                debug_print(f"üìä L·∫ßn s·ª≠ d·ª•ng th·ª©: {usage_count}")
                if last_saved:
                    debug_print(f"üïí L·∫ßn l∆∞u cu·ªëi: {last_saved}")

            debug_print("‚úÖ ƒê√£ t·∫£i settings th√†nh c√¥ng!")

        except Exception as e:
            debug_print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i settings: {e}")
        finally:
            self.loading_settings = False  # B·∫≠t l·∫°i auto-save
            # K·∫øt n·ªëi auto-save sau khi load xong
            self._connect_auto_save()

    def reset_settings(self):
        """Reset t·∫•t c·∫£ settings v·ªÅ m·∫∑c ƒë·ªãnh"""
        reply = QMessageBox.question(
            self, "X√°c nh·∫≠n",
            "üîÑ B·∫°n c√≥ ch·∫Øc mu·ªën reset t·∫•t c·∫£ settings v·ªÅ m·∫∑c ƒë·ªãnh?\n\n‚ö†Ô∏è ƒêi·ªÅu n√†y s·∫Ω x√≥a:\n‚Ä¢ URL ƒë√£ l∆∞u\n‚Ä¢ T·∫•t c·∫£ t√πy ch·ªçn\n‚Ä¢ Th∆∞ m·ª•c t√πy ch·ªçn\n‚Ä¢ V·ªã tr√≠ c·ª≠a s·ªï",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.settings.clear()
            self.load_default_settings()
            QMessageBox.information(
                self, "Th√†nh c√¥ng", "‚úÖ ƒê√£ reset settings v·ªÅ m·∫∑c ƒë·ªãnh!")

    def load_default_settings(self):
        """T·∫£i settings m·∫∑c ƒë·ªãnh"""
        # X√≥a URL
        self.url_input.clear()

        # Ch·∫ø ƒë·ªô video m·∫∑c ƒë·ªãnh
        self.video_radio.setChecked(True)

        # Ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ m·∫∑c ƒë·ªãnh
        self.sub_mode.setCurrentText("ü§ñ Ph·ª• ƒë·ªÅ t·ª± ƒë·ªông")

        # Ng√¥n ng·ªØ m·∫∑c ƒë·ªãnh
        self.sub_lang.setCurrentText("üáªÔøΩÔøΩ Ti·∫øng Vi·ªát (vi)")

        # T√πy ch·ªçn m·∫∑c ƒë·ªãnh
        self.convert_srt.setChecked(True)
        self.audio_only.setChecked(False)
        self.include_thumb.setChecked(False)
        self.subtitle_only.setChecked(False)

        # X√≥a t√™n th∆∞ m·ª•c t√πy ch·ªçn
        self.folder_name_input.clear()

    def auto_save_on_change(self):
        """T·ª± ƒë·ªông l∆∞u khi c√≥ thay ƒë·ªïi (kh√¥ng hi·ªÉn th·ªã th√¥ng b√°o)"""
        # Kh√¥ng l∆∞u n·∫øu ƒëang trong qu√° tr√¨nh load settings
        if hasattr(self, 'loading_settings') and self.loading_settings:
            return

        try:
            # L∆∞u URL ƒë√£ nh·∫≠p
            urls_text = self.url_input.toPlainText().strip()
            self.settings.setValue("urls", urls_text)

            # L∆∞u ch·∫ø ƒë·ªô video
            self.settings.setValue("video_mode", self.video_radio.isChecked())

            # L∆∞u ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ
            self.settings.setValue(
                "subtitle_mode", self.sub_mode.currentText())

            # L∆∞u ng√¥n ng·ªØ ph·ª• ƒë·ªÅ ƒë√£ ch·ªçn
            # Get the current text from the combobox
            selected_lang_code = self._get_selected_language_code()
            # Save as a single string
            self.settings.setValue("selected_language", selected_lang_code)

            # L∆∞u c√°c t√πy ch·ªçn
            self.settings.setValue("convert_srt", self.convert_srt.isChecked())
            self.settings.setValue("audio_only", self.audio_only.isChecked())
            self.settings.setValue(
                "include_thumb", self.include_thumb.isChecked())
            self.settings.setValue(
                "subtitle_only", self.subtitle_only.isChecked())

            # L∆∞u t√™n th∆∞ m·ª•c t√πy ch·ªçn
            custom_folder = self.folder_name_input.toPlainText().strip()
            self.settings.setValue("custom_folder", custom_folder)

            # ƒê·ªìng b·ªô settings ngay l·∫≠p t·ª©c
            self.settings.sync()

            # Debug log (ch·ªâ khi c√≥ thay ƒë·ªïi quan tr·ªçng)
            if custom_folder:
                debug_print(f"üíæ Auto-save: Th∆∞ m·ª•c = {custom_folder}")

        except Exception as e:
            debug_print(f"‚ö†Ô∏è L·ªói auto-save: {e}")

    def debug_settings(self):
        """Debug method ƒë·ªÉ ki·ªÉm tra settings ƒë√£ l∆∞u"""
        debug_print("\nüîç DEBUG SETTINGS:")
        debug_print(
            f"üìÅ Custom folder trong registry: '{self.settings.value('custom_folder', 'EMPTY')}'")
        debug_print(
            f"üìÅ Custom folder trong UI: '{self.folder_name_input.toPlainText()}'")
        debug_print(
            f"üîó URLs trong registry: {len(self.settings.value('urls', '').splitlines())} d√≤ng")
        debug_print(
            f"üîó URLs trong UI: {len(self.url_input.toPlainText().splitlines())} d√≤ng")
        debug_print(
            f"üé¨ Video mode: {self.settings.value('video_mode', 'NONE')}")
        debug_print(
            f"üìù Subtitle mode: {self.settings.value('subtitle_mode', 'NONE')}")
        # Changed from selected_languages
        debug_print(
            f"üåç Languages: {self.settings.value('selected_language', 'NONE')}")
        debug_print("=" * 60)

    def show_about(self):
        """Hi·ªÉn th·ªã th√¥ng tin v·ªÅ ·ª©ng d·ª•ng"""
        about_text = f"""
        <h3>üé¨ HT DownloadVID v{APP_VERSION}</h3>
        <p><b>·ª®ng d·ª•ng download video v√† ph·ª• ƒë·ªÅ</b></p>
        <p>üìÖ Phi√™n b·∫£n: {APP_VERSION}</p>
        <p>üë®‚Äçüíª Ph√°t tri·ªÉn b·ªüi: HT Software</p>
        <p>üîß S·ª≠ d·ª•ng: yt-dlp + ffmpeg</p>
        <br>
        <p><b>T√≠nh nƒÉng:</b></p>
        <ul>
        <li>‚úÖ Download video t·ª´ nhi·ªÅu n·ªÅn t·∫£ng</li>
        <li>‚úÖ H·ªó tr·ª£ playlist</li>
        <li>‚úÖ Download ph·ª• ƒë·ªÅ ƒëa ng√¥n ng·ªØ</li>
        <li>‚úÖ Chuy·ªÉn ƒë·ªïi audio sang MP3</li>
        <li>‚úÖ L∆∞u settings t·ª± ƒë·ªông</li>
        <li>‚úÖ Ki·ªÉm tra c·∫≠p nh·∫≠t t·ª± ƒë·ªông</li>
        </ul>
        """

        QMessageBox.about(self, "V·ªÅ ·ª©ng d·ª•ng", about_text)

    def show_settings_info(self):
        """Hi·ªÉn th·ªã th√¥ng tin v·ªÅ settings ƒë√£ l∆∞u"""
        try:
            usage_count = self.settings.value("usage_count", 0, int)
            last_saved = self.settings.value("last_saved", "Ch∆∞a l∆∞u")

            # ƒê·∫øm s·ªë URL ƒë√£ l∆∞u
            saved_urls = self.settings.value("urls", "")
            url_count = len([url for url in saved_urls.splitlines()
                            if url.strip()]) if saved_urls else 0

            # ƒê·∫øm ng√¥n ng·ªØ ƒë√£ ch·ªçn
            selected_lang_code = self.settings.value("selected_language", "vi")
            lang_display = selected_lang_code if selected_lang_code else "Kh√¥ng c√≥"

            # Ki·ªÉm tra th∆∞ m·ª•c t√πy ch·ªçn - Hi·ªÉn th·ªã chi ti·∫øt h∆°n
            custom_folder = self.settings.value("custom_folder", "")
            folder_display = custom_folder if custom_folder else "Kh√¥ng c√≥"

            info_text = f"""
            <h3>üìä Th√¥ng tin Settings</h3>
            <table border="1" cellpadding="5" cellspacing="0">
            <tr><td><b>üî¢ S·ªë l·∫ßn s·ª≠ d·ª•ng:</b></td><td>{usage_count}</td></tr>
            <tr><td><b>üïí L·∫ßn l∆∞u cu·ªëi:</b></td><td>{last_saved}</td></tr>
            <tr><td><b>üîó S·ªë URL ƒë√£ l∆∞u:</b></td><td>{url_count}</td></tr>
            <tr><td><b>üåç Ng√¥n ng·ªØ ƒë√£ ch·ªçn:</b></td><td>{lang_display}</td></tr>
            <tr><td><b>üìÅ Th∆∞ m·ª•c t√πy ch·ªçn:</b></td><td>{folder_display}</td></tr>
            <tr><td><b>üé¨ Ch·∫ø ƒë·ªô video:</b></td><td>{"Video ƒë∆°n" if self.video_radio.isChecked() else "Playlist"}</td></tr>
            <tr><td><b>üìù Ch·∫ø ƒë·ªô ph·ª• ƒë·ªÅ:</b></td><td>{self.sub_mode.currentText()}</td></tr>
            </table>
            <br>
            <p><b>üîß T√πy ch·ªçn hi·ªán t·∫°i:</b></p>
            <ul>
            <li>üîÅ Convert SRT: {"‚úÖ" if self.convert_srt.isChecked() else "‚ùå"}</li>
            <li>üéµ Audio Only: {"‚úÖ" if self.audio_only.isChecked() else "‚ùå"}</li>
            <li>üñºÔ∏è Include Thumbnail: {"‚úÖ" if self.include_thumb.isChecked() else "‚ùå"}</li>
            <li>üìù Subtitle Only: {"‚úÖ" if self.subtitle_only.isChecked() else "‚ùå"}</li>
            </ul>
            """

            QMessageBox.information(self, "Settings Info", info_text)

            # Debug trong console
            self.debug_settings()

        except Exception as e:
            QMessageBox.warning(
                self, "L·ªói", f"‚ùå Kh√¥ng th·ªÉ hi·ªÉn th·ªã th√¥ng tin settings: {e}")

    def show_log_file(self):
        """Hi·ªÉn th·ªã n·ªôi dung file log"""
        try:
            log_file = os.path.join(os.getcwd(), "DownloadVID.log")

            if os.path.exists(log_file):
                with open(log_file, 'r', encoding='utf-8') as f:
                    log_content = f.read()

                # L·∫•y 50 d√≤ng cu·ªëi
                lines = log_content.splitlines()
                if len(lines) > 50:
                    display_content = '\n'.join(lines[-50:])
                    header = f"üìù Log File (50 d√≤ng cu·ªëi / t·ªïng {len(lines)} d√≤ng)\n{'='*60}\n"
                else:
                    display_content = log_content
                    header = f"üìù Log File (t·ªïng {len(lines)} d√≤ng)\n{'='*60}\n"

                # T·∫°o dialog ƒë·ªÉ hi·ªÉn th·ªã log
                log_dialog = QMessageBox(self)
                log_dialog.setWindowTitle("Log File")
                log_dialog.setText(header + display_content)
                # Full log trong detailed text
                log_dialog.setDetailedText(log_content)
                log_dialog.exec()

            else:
                QMessageBox.information(
                    self, "Log File", "üìù Ch∆∞a c√≥ file log n√†o ƒë∆∞·ª£c t·∫°o.")

        except Exception as e:
            QMessageBox.warning(self, "L·ªói", f"‚ùå Kh√¥ng th·ªÉ ƒë·ªçc file log: {e}")

    def check_tool_versions(self):
        """Hi·ªÉn th·ªã th√¥ng tin phi√™n b·∫£n c·ªßa c√°c c√¥ng c·ª• ƒëang s·ª≠ d·ª•ng"""
        self.output_list.addItem("üîß === TH√îNG TIN PHI√äN B·∫¢N C√îNG C·ª§ ===")

        if ytdlp_executable:
            self.output_list.addItem(f"‚úÖ yt-dlp: {ytdlp_version}")
            self.output_list.addItem(f"üìç ƒê∆∞·ªùng d·∫´n: {ytdlp_executable}")
        else:
            self.output_list.addItem("‚ùå yt-dlp: Kh√¥ng t√¨m th·∫•y!")
            self.output_list.addItem("üí° H∆∞·ªõng d·∫´n c√†i ƒë·∫∑t:")
            self.output_list.addItem(
                "   1. T·∫£i yt-dlp.exe t·ª´: https://github.com/yt-dlp/yt-dlp/releases")
            self.output_list.addItem(
                "   2. ƒê·∫∑t file yt-dlp.exe v√†o th∆∞ m·ª•c ch·ª©a App.py")
            self.output_list.addItem(
                "   3. Ho·∫∑c c√†i ƒë·∫∑t qua pip: pip install yt-dlp")

        if os.path.exists(ffmpeg_path):
            self.output_list.addItem("‚úÖ ffmpeg: ƒê√£ s·∫µn s√†ng")
            self.output_list.addItem(f"üìç ƒê∆∞·ªùng d·∫´n: {ffmpeg_path}")
        else:
            self.output_list.addItem("‚ö†Ô∏è ffmpeg: Kh√¥ng t√¨m th·∫•y")
            self.output_list.addItem("üí° H∆∞·ªõng d·∫´n c√†i ƒë·∫∑t:")
            self.output_list.addItem(
                "   1. T·∫£i FFmpeg t·ª´: https://ffmpeg.org/download.html")
            self.output_list.addItem(
                "   2. Gi·∫£i n√©n v√† ƒë·∫∑t file ffmpeg.exe v√†o th∆∞ m·ª•c ch·ª©a App.py")
            self.output_list.addItem(
                "   3. Ho·∫∑c c√†i ƒë·∫∑t qua pip: pip install ffmpeg-python")

        self.output_list.addItem("üîß ========================")
        self.scroll_to_bottom()

    def auto_check_update(self):
        """T·ª± ƒë·ªông ki·ªÉm tra update khi kh·ªüi ƒë·ªông (hi·ªÉn th·ªã th√¥ng b√°o n·∫øu c√≥ update)"""
        # Ki·ªÉm tra xem c√≥ n√™n auto-check kh√¥ng (c√≥ th·ªÉ th√™m setting ƒë·ªÉ t·∫Øt/b·∫≠t)
        auto_check_enabled = self.settings.value(
            "auto_check_update", True, bool)
        if not auto_check_enabled:
            return

        # Ki·ªÉm tra l·∫ßn cu·ªëi check (tr√°nh check qu√° th∆∞·ªùng xuy√™n)
        # last_check = self.settings.value("last_update_check", "")
        # if last_check:
        #     try:
        #         from datetime import datetime, timedelta
        #         last_check_date = datetime.fromisoformat(last_check)
        #         if datetime.now() - last_check_date < timedelta(days=1):
        #             debug_print(
        #                 "üîÑ ƒê√£ check update trong 24h qua, b·ªè qua auto-check")
        #             return
        #     except:
        #         pass

        # Hi·ªÉn th·ªã th√¥ng b√°o ƒëang ki·ªÉm tra
        self.output_list.addItem("üîÑ ƒêang ki·ªÉm tra phi√™n b·∫£n m·ªõi...")
        self.scroll_to_bottom()
        
        self._start_update_check(silent=False)  # Thay ƒë·ªïi t·ª´ silent=True th√†nh silent=False

    def manual_check_update(self):
        """Ki·ªÉm tra update th·ªß c√¥ng (c√≥ th√¥ng b√°o)"""
        self.output_list.addItem("üîÑ ƒêang ki·ªÉm tra phi√™n b·∫£n m·ªõi...")
        self.scroll_to_bottom()
        self._start_update_check(silent=False)

    def _start_update_check(self, silent=False):
        """B·∫Øt ƒë·∫ßu ki·ªÉm tra update"""
        if self.update_checker and self.update_checker.isRunning():
            if not silent:
                QMessageBox.information(
                    self, "Th√¥ng b√°o", "ƒêang ki·ªÉm tra update, vui l√≤ng ƒë·ª£i...")
            return

        self.update_checker = UpdateChecker()
        self.update_checker.update_available.connect(
            lambda info: self._on_update_available(info, silent))
        self.update_checker.no_update.connect(
            lambda: self._on_no_update(silent))
        self.update_checker.error_occurred.connect(
            lambda error: self._on_update_error(error, silent))
        self.update_checker.start()

        # L∆∞u th·ªùi gian check
        self.settings.setValue("last_update_check", datetime.now().isoformat())

    def _on_update_available(self, update_info, silent):
        """X·ª≠ l√Ω khi c√≥ update"""
        debug_print(f"üéâ Phi√™n b·∫£n m·ªõi c√≥ s·∫µn: v{update_info['version']}")

        if not silent:
            self.output_list.addItem(
                f"üéâ Phi√™n b·∫£n m·ªõi c√≥ s·∫µn: v{update_info['version']}")
            self.scroll_to_bottom()
        else:
            # Khi auto-check v√† t√¨m th·∫•y update, hi·ªÉn th·ªã th√¥ng b√°o ƒë·∫∑c bi·ªát
            self.output_list.addItem("=" * 50)
            self.output_list.addItem(f"üö® PH√ÅT HI·ªÜN PHI√äN B·∫¢N M·ªöI!")
            self.output_list.addItem(f"üéâ Phi√™n b·∫£n m·ªõi: v{update_info['version']}")
            self.output_list.addItem(f"üì± Phi√™n b·∫£n hi·ªán t·∫°i: v{APP_VERSION}")
            self.output_list.addItem("üîÑ Dialog c·∫≠p nh·∫≠t s·∫Ω m·ªü trong gi√¢y l√°t...")
            self.output_list.addItem("=" * 50)
            self.scroll_to_bottom()

        # Hi·ªÉn th·ªã dialog update
        dialog = UpdateDialog(update_info, self)
        dialog.exec()

    def _on_no_update(self, silent):
        """X·ª≠ l√Ω khi kh√¥ng c√≥ update"""
        debug_print("‚úÖ B·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t")

        if not silent:
            self.output_list.addItem("‚úÖ B·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t")
            self.scroll_to_bottom()
            # Ch·ªâ hi·ªÉn th·ªã MessageBox khi check th·ªß c√¥ng, kh√¥ng hi·ªÉn th·ªã khi auto-check
            # QMessageBox.information(
            #     self, "Th√¥ng b√°o", f"‚úÖ B·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t (v{APP_VERSION})")
        else:
            # Khi auto-check, ch·ªâ hi·ªÉn th·ªã trong log
            self.output_list.addItem("‚úÖ Phi√™n b·∫£n hi·ªán t·∫°i l√† m·ªõi nh·∫•t")
            self.scroll_to_bottom()

    def _on_update_error(self, error_message, silent):
        """X·ª≠ l√Ω l·ªói khi ki·ªÉm tra update"""
        debug_print(f"‚ö†Ô∏è L·ªói ki·ªÉm tra update: {error_message}")

        if not silent:
            self.output_list.addItem(
                f"‚ö†Ô∏è L·ªói ki·ªÉm tra update: {error_message}")
            self.scroll_to_bottom()
            QMessageBox.warning(
                self, "L·ªói", f"‚ö†Ô∏è Kh√¥ng th·ªÉ ki·ªÉm tra update:\n{error_message}")
        else:
            # Khi auto-check g·∫∑p l·ªói, ch·ªâ hi·ªÉn th·ªã trong log (kh√¥ng popup)
            self.output_list.addItem(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ki·ªÉm tra c·∫≠p nh·∫≠t: {error_message}")
            self.output_list.addItem("üí° B·∫°n c√≥ th·ªÉ ki·ªÉm tra th·ªß c√¥ng qua menu Help > Check for Updates")
            self.scroll_to_bottom()

    def closeEvent(self, event):
        """X·ª≠ l√Ω khi ƒë√≥ng ·ª©ng d·ª•ng - t·ª± ƒë·ªông l∆∞u settings"""
        try:
            # L∆∞u settings kh√¥ng hi·ªÉn th·ªã th√¥ng b√°o
            self.auto_save_on_change()

            # L∆∞u v·ªã tr√≠ c·ª≠a s·ªï cu·ªëi c√πng
            self.settings.setValue("geometry", self.saveGeometry())

            # C·∫≠p nh·∫≠t th·ªùi gian ƒë√≥ng ·ª©ng d·ª•ng
            from datetime import datetime
            self.settings.setValue("last_closed", datetime.now().isoformat())

        except Exception as e:
            debug_print(f"‚ö†Ô∏è L·ªói khi l∆∞u settings: {e}")

        event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = DownloaderApp()
    win.show()
    sys.exit(app.exec())
